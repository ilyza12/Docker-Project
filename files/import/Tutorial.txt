CPT316: Programming Language Implementation and Paradigms  
Tutorial 1 (4-11-22) 
 
1- What is the Programming Language Paradigms?  
Answer: 
A programming paradigm is a paradigmatic style of programming (compare with a methodology 
which is a paradigmatic style of doing software engineering). 
A programming paradigm provides (and determines) the view that the programmer has of the 
execution of the program. 
 
2- Explain 5 of the Programming Language Paradigms? 
Answer: 
• Imperative 
• Functional 
• Logical 
• Object-Oriented 
• Parallel 
 
3- What is the difference between a compiler and an interpreter? 
Answer 
A compiler is a program that can read a program in one language - the source language - 
and translate it into an equivalent program in another language – the target language 
and report any errors in the source program that it detects during the translation 
process. 
Interpreter directly executes the operations specified in the source program on inputs 
supplied by the user. 
 
 
 
 
 
4- What are the advantages of: (a) a compiler over an interpreter (b) an interpreter over a 
compiler? 
Answer 
a. The machine-language target program produced by a compiler is usually much faster 
than an interpreter at mapping inputs to outputs. 
b. An interpreter can usually give better error diagnostics than a compiler, because it 
executes the source program statement by statement. 
 
5- What is the meaning of the Tokens, Patterns and Lexemes? 
Answer: 
Tokens - describes the class or category of input string. Eg. Identifiers, keywords, constants 
are called tokens. (Token name, Token value) 
Pattern – set of rules that describe the token 
Lexeme - a sequence of characters in the source program that matches the pattern for a 
token. 
    Eg. Int, i, num, ans, 
 
6- Consider the context-free grammar: 
S -> S S + | S S * | a 
1- Show how the string aa+a* can be generated by this grammar. 
2- Construct a parse tree for this string. 
3- What language does this grammar generate? Justify your answer. 
Answer: 
1. S -> S S -> S S + S -> a S + S -> a a + S -> a a + a * 
2.  
3. L = {Postfix expression consisting of digits, plus and multiple signs} 
 
7- Construct a context-free grammar for roman numerals. 
  I, II, III, I V , V, V I, V II, V III, I X 
Note: we just consider a subset of roman numerals which is less than 4k. 
Answer: 
• We can categorize the single roman numerals into 4 groups: 
•   I, II, III | I V | V, V I, V II, V III | I X 
then get the production: 
  digit -> smallDigit | I V | V smallDigit | I X 
  smallDigit -> I | II | III | ε 
• and we can find a simple way to map roman to arabic numerals. For example: 
o XII => X, II => 10 + 2 => 12 
o CXCIX => C, XC, IX => 100 + 90 + 9 => 199 
o MDCCCLXXX => M, DCCC, LXXX => 1000 + 800 + 80 => 1880 
• via the upper two rules, we can derive the production: 
romanNum -> thousand hundred ten digit 
thousand -> M | MM | MMM | ε 
hundred -> smallHundred | C D | D smallHundred | C M 
smallHundred -> C | CC | CCC | ε 
ten -> smallTen | X L | L smallTen | X C 
smallTen -> X | XX | XXX | ε 
digit -> smallDigit | I V | V smallDigit | I X 
smallDigit -> I | II | III | ε 
 
 
 
 
 
 
8-   For this regular expression:           (a + b)*abb  
1. construct an NFA accepting the regular language. 
 
 
2. construct a corresponding DFA. 
 
